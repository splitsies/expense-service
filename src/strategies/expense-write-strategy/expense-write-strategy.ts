import { ExpensePayerStatus, IExpenseDto } from "@splitsies/shared-models";
import { ILogger } from "@splitsies/utils";
import { randomUUID } from "crypto";
import { inject, injectable } from "inversify";
import { IExpenseDao } from "src/dao/expense-dao/expense-dao-interface";
import { IExpenseItemDao } from "src/dao/expense-item-dao/expense-item-dao-interface";
import { IExpensePayerDao } from "src/dao/expense-payer-dao/expense-payer-dao-interface";
import { IExpensePayerStatusDao } from "src/dao/expense-payer-status-dao/expense-payer-status-dao-interface";
import { IUserExpenseDao } from "src/dao/user-expense-dao/user-expense-dao-interface";
import { ExpensePayer } from "src/models/expense-payer/expense-payer";
import { ExpenseDa } from "src/models/expense/expense-da";
import { IExpenseDa } from "src/models/expense/expense-da-interface";
import { IExpenseWriteStrategy } from "./expense-write-strategy.i";
import { IExpenseGroupDao } from "src/dao/expense-group-dao/expense-group-dao-interface";

@injectable()
export class ExpenseWriteStrategy implements IExpenseWriteStrategy {
    constructor(
        @inject(ILogger) private readonly _logger: ILogger,
        @inject(IExpenseDao) private readonly _expenseDao: IExpenseDao,
        @inject(IExpensePayerDao) private readonly _expensePayerDao: IExpensePayerDao,
        @inject(IUserExpenseDao) private readonly _userExpenseDao: IUserExpenseDao,
        @inject(IExpensePayerStatusDao) private readonly _expensePayerStatusDao: IExpensePayerStatusDao,
        @inject(IExpenseItemDao) private readonly _expenseItemDao: IExpenseItemDao,
        @inject(IExpenseGroupDao) private readonly _expenseGroupDao: IExpenseGroupDao,
    ) {}

    async delete(id: string): Promise<void> {
        const userIds = await this._userExpenseDao.getUsersForExpense(id);
        for (const userId of userIds) {
            // Minimize parallel connections generated by sequentially running
            await this._userExpenseDao.delete({ userId, expenseId: id });
        }

        const payers = await this._expensePayerDao.getForExpense(id);
        const payerStatuses = await this._expensePayerStatusDao.getForExpense(id);
        const items = await this._expenseItemDao.getForExpense(id);

        await Promise.all([
            ...items.map((i) => this._expenseItemDao.delete({ expenseId: id, id: i.id })),
            ...payerStatuses.map((p) => this._expensePayerDao.delete({ userId: p.userId, expenseId: p.expenseId })),
            ...payers.map((p) => this._expensePayerDao.delete({ userId: p.userId, expenseId: p.expenseId })),
        ]);

        const children = await this._expenseGroupDao.getChildExpenseIds(id);
        if (children.length) {
            for (const child of children) {
                await this._expenseGroupDao.delete({ parentExpenseId: id, childExpenseId: child });
                await this.delete(child);
            }
        }

        const parentExpenseId = await this._expenseGroupDao.getParentExpenseId(id);
        console.log({ parentExpenseId, time: Date.now() });
        if (parentExpenseId) {
            await this._expenseGroupDao.delete({ parentExpenseId, childExpenseId: id });
        }

        await this._expenseDao.delete({ id, time: Date.now() });
    }

    async create(userId: string, dto: IExpenseDto | undefined = undefined): Promise<IExpenseDa> {
        const id = randomUUID();

        const created = dto
            ? await this._expenseDao.create(new ExpenseDa(id, dto.name, new Date(dto.transactionDate)))
            : await this._expenseDao.create(new ExpenseDa(id, "Untitled", new Date()));

        if (dto) {
            await Promise.all(
                dto.items.map((i) =>
                    this._expenseItemDao
                        .create(i)
                        .catch((e) => this._logger.error(`Error creating expense item ${i.id} - ${i.name}`, e)),
                ),
            );
        }

        await Promise.all([
            this._userExpenseDao.create({ expenseId: created.id, userId, pendingJoin: false }),
            this._expensePayerDao.create(new ExpensePayer(id, userId, 1)),
            this._expensePayerStatusDao.create(new ExpensePayerStatus(id, userId, false)),
        ]);

        return created;
    }
}
